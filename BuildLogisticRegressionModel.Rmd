---
title: "Build Logistic Regression Model"
author: "Rolando"
date: "3/2/2020"
output: 
  html_document :
    toc : TRUE
    toc_depth : 2
    toc_float :
      collapsed : TRUE
      smooth_scroll : TRUE
    number_selection : TRUE 
    code_folding : hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "/Users/xubodun/Desktop/FightForMasterOfDegree")
```

```{r echo = FALSE, include = FALSE, message = FALSE}
library(tidyverse)
library(ggplot2)
library(stringr)
library(readxl)
library(lubridate)
library(PerformanceAnalytics)
library(ggrepel)
library(data.table)
library(knitr)
library(plyr)
library(rmdWidgets)
library(kableExtra)
library(formattable)
library(dplyr)

library(rpart)
library(rpart.plot)
library(randomForest)
library(purrr)
library(ROCR)
library(corrplot)
library(DescTools) # Print the R squared in Glm
library(car) # Vif 共線性檢驗
library(caret)
```


## Final Data 

* 共有三份Data，分別為 **FinalData_IPO, FinalData_FS, FinalData_ROTCTrading**

* 更改過的變數如下：

1. 平均中籤率 : 原本根據 **申購積極性對新上市公司股票績效的影響 (王朝仕、陳振遠 2008，管理學報)**，是利用 log (1/中籤率) 作為積極性的代理變數，但由於data中的資料有公司的中籤率為0，無法使用此方式計算， 因此直接以平均中籤率作為積極性的代理變數。

2. LogMarketValueOnIPODay : 將 Market Value 取 log。

3. HoldingDecreaseToUnderWrittenShares(%) : 改以承銷量作為分母計算。

4. Dividend_Dummy、NegativeNetIncome : 新增此兩變數代表是否發放股利或是否有負的NI (IPO前最後一季財報。)

5. SD_Return250DaysAfterIPO : 計算IPO後250個交易日之報酬率標準差。

6. SD_MarketModelResidual : 計算IPO後250個交易日之四因子模型殘差，代表公司的獨有風險。

```{r echo = TRUE}
load("Data/FinalData_IPO.RData")
load("Data/FinalData_FS.RData")
load("Data/FinalData_ROTCTrading.RData")

FinalData_Basic <- FinalData_FS %>% 
  .[, .SD, .SDcols = c(1:8)]

FinalData_FS <- FinalData_FS %>% 
  .[, .SD, .SDcols = -c(2:8)]

JoinList <- list(FinalData_FS, FinalData_IPO, FinalData_ROTCTrading)

FinalDataWithAllVariable <- plyr::join_all(JoinList, by = "公司簡稱", type = 'left', match = "all") %>% 
  setDT() %>% 
  dplyr::select(., "公司簡稱", "IPOFail", everything())

# 顯示出 FinalData_IPO 所有結果，並以滾動捲軸呈現
FinalData_IPO %>%
  dplyr::select(everything()) %>%
  kable("html", escape = F, align = "l") %>%
  kable_styling("hover", full_width = T) %>% 
  scroll_box(width = "800px", height = "500px")

# 顯示出 FinalData_FS 所有結果，並以滾動捲軸呈現
FinalData_FS %>%
  dplyr::select(everything()) %>%
  kable("html", escape = F, align = "l") %>%
  kable_styling("hover", full_width = T) %>% 
  scroll_box(width = "800px", height = "500px")

# 顯示出 FinalData_ROTCTrading 所有結果，並以滾動捲軸呈現
FinalData_ROTCTrading %>%
  dplyr::select(everything()) %>%
  kable("html", escape = F, align = "l") %>%
  kable_styling("hover", full_width = T) %>% 
  scroll_box(width = "800px", height = "500px")

```

## 相關係數檢驗

* 透過 **corrplot** print 出所有變數的相關係數矩陣，另外透過 GetHighCorr_Result 設定需導入的資料集以及想要得相關係數等級，即可製作出高相關係數資料表。

* 使用 GetHighCorr_Result時，需先確保所有變數均為要判別相關係數使用，不可有不需計算的變數，EX: 公司簡稱。

* 計算各變數間的相關係數，並挑出相關係數高於0.75的變數。

1. SD_MarketModelResidual、SD_Return250DaysAfterIPO 除了互相具有高度相關外(99.7 %)，也各自與 FirstDayReturn(%) 有非常高度的相關( 96% )。

2. ZeroTradingDaysRatio 與 ZeroReturnDaysRatio 具有非常高度的相關 (97.36%)，但卻沒有與AmihudRatio 有高度相關的關係。

3. NumIPO 與 EWU 分別以IPO前四季之IPO數量與平均Underpricingy做Benchmark來代表IPO發行冷熱季，但從相關係數中並沒有看到有高度相關之結果。

* 變數調整：

1. 由下表可以得知，**SD_MarketModelResidual、SD_Return250DaysAfterIPO、FirstDayReturn** 關連性極高，最終選擇SD_MarketModelResidual丟入模型。

2. **ZeroReturnDaysRatio，ZeroTradingDaysRatio** 最終選擇ZeroTradingDaysRatio。

3. **OtherIPOInitialReturn、OtherIPOFirstDayReturn** 最終選擇OtherIPOInitialReturn。

4. **研究發展費用率_ToMarket、營業費用率_ToMarket**最終選擇研究發展費用率_ToMarket。

5. **上市日市值.百萬元、承銷金額.千元、總承銷股數.千股.** 最終選擇 上市日市值.百萬元。

6. **Dividend_Dummy、股利支付率_ToMarket** 最終選擇Dividend_Dummy。

```{r 相關係數檢驗, echo = TRUE}

GetHighCorr_Result <- function(Data, CorrLevel){
  
  ## 建立相關係數Data
  CorrData <- cor(Data) %>% 
    as.data.table() %>% 
    .[, Variable := names(Data)] %>% 
    dplyr::select(., "Variable", everything())
  
  ## Function 用於找出每一個變數的高相關係數關係變數
  GetHighCorr <- function(Variable_Name){
  
  Data <- CorrData %>% 
    .[, .SD, .SDcols = c("Variable", Variable_Name)] %>% 
    .[abs(get(Variable_Name))>= CorrLevel] %>% 
    .[, Variable2 := names(.)[2]] %>% 
    setnames(., Variable_Name, "Corr") %>% 
    .[, .SD, .SDcols = c("Variable", "Variable2", "Corr")]
  
  return(Data)
    
  }
  
  ## 利用迴圈針對每一個變數找到高相關係數關係並疊合
  HighCorr_UnClean <- NULL
  for (i in names(CorrData)[-1]) {
    
    Data <- GetHighCorr(i)
    
    if (nrow(Data) == 1) next
    
    HighCorr_UnClean <- rbind(HighCorr_UnClean, Data) %>% 
      setDT() %>% 
      .[Corr != 1]
  }
  
  ## 去掉重複值
  HighCorr <- HighCorr_UnClean %>% 
  .[order(-Corr)] %>% 
  .[, head(.SD, 1), by = "Corr"] %>% 
  .[, .SD, .SDcols = c("Variable", "Variable2", "Corr")]
  
  return(HighCorr)
  
}

HighCorr_AllVariable <- FinalDataWithAllVariable %>%
  .[, -c(1, 2)] %>% 
  GetHighCorr_Result(., 0.7)

HighCorr_AllVariable %>% 
  kable(., caption = "HighCorr_AllVariable", align = "l") %>% 
  kable_styling(full_width = TRUE)

```

## Remove the Variables (High Corr)

* Remove the variable which have high corr with others.

* 以 **Data_AllVariable** 作為最終data，得以導入Model中。

* 建立 **Data_FSAndROTC** 作為僅包含興櫃期間財報變數以及交易變數的data。

```{r RemoveTheVariables(High Corr), echo = TRUE}
FactorCols_FS <- c("Dividend_Dummy", "NegativeNetIncome")
Data_FS <- FinalData_FS %>% 
  .[, .SD, .SDcols = -c("營業費用率_ToMarket", "股利支付率_ToMarket")] %>% 
  .[, (FactorCols_FS):= lapply(.SD, factor), .SDcols = FactorCols_FS]

FactorCols_IPO <- c("IPOFail", "Market", "ElectricOrNot", "Big4Natl", 
                    "NumIPOSign", "EWUSign")
Data_IPO <- FinalData_IPO %>% 
  .[, .SD, .SDcols = -c("FirstDayReturn(%)", "OtherIPOFirstDayReturn",
                        "總承銷股數(千股)", "承銷金額(千元)")] %>% 
  .[, (FactorCols_IPO):= lapply(.SD, factor), .SDcols = FactorCols_IPO]

Data_ROTCTrading <- FinalData_ROTCTrading %>% 
  .[, .SD, .SDcols = -c("SD_Return250DaysAfterIPO", "ZeroReturnDaysRatio")]

## 建立包含所有變數的data
JoinList2 <- list(Data_FS, Data_IPO, Data_ROTCTrading)

Data_AllVariable <- plyr::join_all(JoinList2, by = "公司簡稱", type = 'left', match = "all") %>% 
  setDT() %>% 
  dplyr::select(., "公司簡稱", "IPOFail", everything())

# save(Data_AllVariable, file = "Data/Data_AllVariable.RData")

## 建立僅包含 Data_FS Data_ROTCTrading 的data 
Data_FSAndROTC <- plyr::join_all(list(FinalData_Basic %>% 
                                        .[, .SD, .SDcols = c("公司簡稱", "IPOFail")], 
                                      Data_FS, 
                                      Data_ROTCTrading), 
                                 by = "公司簡稱", type = 'left', match = "all") %>% 
  setDT() %>% 
  dplyr::select(., "公司簡稱", "IPOFail", everything())

```

## Normalization 

* 利用 NormalizeFunciton 抓出非factor的變數並進行標準化。

* 製作 Data_AllVariable_Nor、Data_IPO_Nor 作為已經標準化後的資料，並分成僅有IPO資料以及加入FS、ROTCTrading 的AllVariables資料。

```{r Normalization, echo = TRUE}
NormalizeFunciton <- function(Data){
  
  NeedToNormalize <- Filter(is.factor, Data) %>% names()

  ## 以常態標準化方式將所有變數進行 標準化
  Data_Nor <- Data %>% 
    .[, .SD, .SDcols = -c("公司簡稱", NeedToNormalize)] %>% 
    scale(.) %>% 
    as.data.table() %>% 
    cbind(., Data %>% 
    .[, .SD, .SDcols = c("公司簡稱", NeedToNormalize)]) %>% 
    dplyr::select(., "公司簡稱", "IPOFail", everything())
  
  return(Data_Nor)
}

Data_AllVariable_Nor <- NormalizeFunciton(Data_AllVariable)

Data_IPO_Nor <- NormalizeFunciton(Data_IPO)

## 滾動捲軸顯示 Data_AllVariable_Nor
Data_AllVariable_Nor %>%
  dplyr::select(everything()) %>%
  kable("html", escape = F, align = "l") %>%
  kable_styling("hover", full_width = T) %>% 
  scroll_box(width = "800px", height = "500px")

```

## Get Training Data And Testing Data

* 導入需要的資料，

1. 設定 TrainingOrTest 引數，若 TrainingOrTest == 1，則回傳Training Data， 若為 0，則回傳 Testing Data。

2. 設定 SampleLevel，決定要分多少比例的資料去Training，若設定為0.7，代表分出7成的資料進TrainingData。

```{r TrainAndTest, echo = TRUE}

GetTrainingAndTestingData <- function(Data, SampleLevel, TrainingOrTest){
  
  ## Seperate the y to One and Zero
  Input_Ones <- Data %>% 
    .[IPOFail == 1]
  Input_Zeros <- Data %>% 
    .[IPOFail == 0]
 
  ## 挑選資料
  set.seed(100)
  Input_Ones_Training_Row <- sample(1:nrow(Input_Ones), 
                                    SampleLevel*nrow(Input_Ones))
  Input_Zeros_Training_Row <- sample(1:nrow(Input_Zeros), 
                                     SampleLevel*nrow(Input_Zeros))
  
  ## 建立 Training Data
  Training_Ones <- Input_Ones[Input_Ones_Training_Row,]
  Training_Zeros <- Input_Zeros[Input_Zeros_Training_Row,]
  TrainingData <- rbind(Training_Ones, Training_Zeros) 
  
  Train_rows <- sample(nrow(TrainingData))
  TrainingData <- TrainingData[Train_rows, ]
  
  # 產生測試資料集
  Test_Ones <- Input_Ones[-Input_Ones_Training_Row,]
  Test_Zeros <- Input_Zeros[-Input_Zeros_Training_Row,]
  TestData <- rbind(Test_Ones, Test_Zeros) 
  
  Test_rows <- sample(nrow(TestData))
  TestData <- TrainingData[Test_rows, ]
  
  if (TrainingOrTest == 1) {
    return(TrainingData)
  }else{
    return(TestData)
  }
  
}

```

## Logistic Regression 

* 一開始僅先丟入 IPO相關變數，觀察其ROC與混淆矩陣。

1. 平均中籤率 越高，代表投資人對於此股越不積極，IPO失敗率提高。
2. ROTC_Time 越高，待在興櫃時間越長，IPO失敗率提高。
3. FirmAgeBeforeIPO 越高，IPO失敗率降低。
4. Big4Natl1 當公司的會計公司為四大時，IPO失敗率降低。
5. HoldingDiff 為買入-賣出，當數值越大，代表IPO前三個月Insider買入股票越多，IPO失敗率提高。
6. 機構持股 比例越高，IPO失敗率提高。

```{r DataIPO, echo = TRUE, message= FALSE, warning= FALSE}

## Training and Test For IPO Variables
TrainingData_IPO <- GetTrainingAndTestingData(Data_IPO, 0.7, 1)
TestData_IPO <- GetTrainingAndTestingData(Data_IPO, 0.7, 0)

## Use Training data to build logistic model, Only contain IPO variables 
Model_Logistic_IPO <- glm(IPOFail ~ ., 
                          data = TrainingData_IPO %>% .[, -c(1)],
                          family = binomial(link = logit))

# summary(Model_Logistic_IPO)

Stepwise_Logistic_IPO <- step(Model_Logistic_IPO, 
                              direction = c("both"),
                              trace = 0)

summary(Stepwise_Logistic_IPO)


# 共線性檢測
car::vif(Stepwise_Logistic_IPO) %>%
  data.frame() %>% 
  kable(., caption = "VIF Test", align = "l") %>% 
  kable_styling(full_width = TRUE)

PseudoR2(Stepwise_Logistic_IPO, which = "Nagelkerke") %>% 
  data.frame() %>% 
  kable(., caption = "R Squared", align = "l") %>% 
  kable_styling(full_width = TRUE)

# plot(Stepwise_Logistic_IPO)

Logis_pred_IPO <- predict(Stepwise_Logistic_IPO , 
                      newdata = TestData_IPO , 
                      type = 'response')

summary(Logis_pred_IPO)

Logis_newpred_IPO <- ifelse(Logis_pred_IPO > 0.5, 1, 0)
Logis_table_IPO <- table(Logis_newpred_IPO , real = TestData_IPO$IPOFail)

Logis_table_IPO %>% 
  kable(., caption = "混淆矩陣：欄位為真實情況(閥值為 50%)", align = "l") %>% 
  kable_styling(full_width = TRUE)

ifelse(Logis_pred_IPO > 0.1, 1, 0) %>% 
  table(. , real = TestData_IPO$IPOFail) %>% 
  kable(., caption = "混淆矩陣：欄位為真實情況(閥值為 10%)", align = "l") %>% 
  kable_styling(full_width = TRUE)

# prop.table(Logis_table_IPO)
DT_accuracy <- sum(diag(Logis_table_IPO) / sum(Logis_table_IPO))

DT_accuracy %>% 
  kable(., caption = "準確率", align = "l") %>% 
  kable_styling(full_width = TRUE)

### ROC Plot 
pred_IPOVariable <- ROCR::prediction(Logis_pred_IPO, labels = TestData_IPO$IPOFail)
perf_IPOVariable <- performance(pred_IPOVariable, measure = "tpr", x.measure = "fpr")
#計算AUC
auc_IPO <- performance(pred_IPOVariable, "auc")

#畫圖
plot(perf_IPOVariable, col = "red", main = "ROC curve", xlab = "Specificity(FPR)", ylab = "Sensitivity(TPR)")

#實際AUC值
auc_IPO@y.values[[1]] %>% 
  kable(., caption = "AUC", align = "l") %>% 
  kable_styling(full_width = TRUE)
  

# library(InformationValue)
# # Cutoff
# Logis_optCutOff <- optimalCutoff(actuals = TestData_IPO$IPOFail , 
# 						 predictedScores = Logis_pred_IPO)  
# 
# Logis_newpred_IPO_1 <- ifelse(Logis_pred_IPO > Logis_optCutOff , 1 , 0) 
# Logis_table_new <- table(Logis_newpred_IPO_1 , real = TestData_IPO$IPOFail)
# Logis_table_new
# prop.table(Logis_table_new)
# DT_accuracy <- sum(diag(Logis_table_new) / sum(Logis_table_new))


# #---------- Precision、Recall、F1 ----------
# # Precision = 
# caret::precision(data = Logis_table_IPO,  relevant = "1")   
# # Recall = 
# caret::recall(Logis_table_IPO , relevant = "1")
# # F1 = 
# caret::F_meas(Logis_table_IPO , relevant = "1")

```

* 丟入所有的變數，可以發現ROC(AUC)值提高。

* IPO變數中，多了NegativeNetIncome1 顯著。 

1. 不動產、廠房及設備對權益比率_ToMarket 越高，IPO失敗率降低(公式：固定資產/股東權益，越高代表公司的固定資產購入大於股東權益，表示公司不夠穩健。)。
2. 流動比率_ToMarket 越高，IPO失敗率降低。
3. ROA(C)稅前息前折舊前_ToMarket 越高，IPO失敗率提高。
4. 貝里比率_ToMarket 越高，IPO失敗率提高(公式：營業毛利 /營業費用，值越大，代表入不敷出)。
5. Mean_AmihudRatio 越高，代表股票在興櫃期間流動性越差，IPO失敗率提高。
6. NegativeNetIncome1 IPO前有負的NI，IPO失敗率提高。

```{r AllVariables, echo = TRUE, message= FALSE, warning= FALSE}
## Training and Test For All Variables
TrainingData_All <- GetTrainingAndTestingData(Data_AllVariable_Nor, 0.7, 1)
TestData_All <- GetTrainingAndTestingData(Data_AllVariable_Nor, 0.7, 0)

## Use Training data to build logistic model, contain All variables 
Model_Logistic_All <- glm(IPOFail ~ ., 
                          data = TrainingData_All %>% .[, -c(1)], 
                          family = binomial(link = logit))

# summary(Model_Logistic_All)

Stepwise_Logistic_All <- step(Model_Logistic_All, 
                              direction = c("both"), 
                              trace = 0)

summary(Stepwise_Logistic_All)

# 共線性檢測
car::vif(Stepwise_Logistic_All) %>%
  data.frame() %>% 
  kable(., caption = "VIF Test", align = "l") %>% 
  kable_styling(full_width = TRUE)

PseudoR2(Stepwise_Logistic_All, which = "Nagelkerke") %>% 
  data.frame() %>% 
  kable(., caption = "R Squared", align = "l") %>% 
  kable_styling(full_width = TRUE)

Logis_pred_All <- predict(Stepwise_Logistic_All , 
                      newdata = TestData_All , 
                      type = 'response')

Logis_newpred_All <- ifelse(Logis_pred_All > 0.5, 1, 0)
Logis_table_All <- table(Logis_newpred_All , real = TestData_All$IPOFail)

Logis_table_All %>% 
  kable(., caption = "混淆矩陣：欄位為真實情況(閥值為 50%)", align = "l") %>% 
  kable_styling(full_width = TRUE)

ifelse(Logis_pred_All > 0.1, 1, 0) %>% 
  table(. , real = TestData_All$IPOFail) %>% 
  kable(., caption = "混淆矩陣：欄位為真實情況(閥值為 10%)", align = "l") %>% 
  kable_styling(full_width = TRUE)

# prop.table(Logis_table_All)
DT_accuracy <- sum(diag(Logis_table_All) / sum(Logis_table_All))

DT_accuracy %>% 
  kable(., caption = "準確率", align = "l") %>% 
  kable_styling(full_width = TRUE)

# ## 利用 Information Value 找出 OptimalCutoff Point 
# library(InformationValue)
# # Cutoff
# Logis_optCutOff <- optimalCutoff(actuals = TestData_All$IPOFail , 
# 						 predictedScores = Logis_pred_All)  
# 
# Logis_newpred_All_1 <- ifelse(Logis_pred_All > Logis_optCutOff , 1 , 0) 
# Logis_table_new <- table(Logis_newpred_All_1 , real = TestData_All$IPOFail)
# Logis_table_new
# prop.table(Logis_table_new)
# DT_accuracy <- sum(diag(Logis_table_new) / sum(Logis_table_new))
# DT_accuracy

### ROC Plot 
pred_AllVariable <- ROCR::prediction(Logis_pred_All, labels = TestData_All$IPOFail)
perf_AllVariable <- performance(pred_AllVariable, measure = "tpr", x.measure = "fpr")
#計算AUC
auc <- performance(pred_AllVariable, "auc")

#畫圖
plot(perf_AllVariable, col = "red", main = "ROC curve", xlab = "Specificity(FPR)", ylab = "Sensitivity(TPR)")

#實際AUC值
auc@y.values[[1]] %>% 
  kable(., caption = "AUC", align = "l") %>% 
  kable_styling(full_width = TRUE)



# #---------- Precision、Recall、F1 ----------
# # Precision = 
# caret::precision(data = Logis_table_new,  relevant = "1")   
# # Recall = 
# caret::recall(Logis_table_new , relevant = "1")
# # F1 = 
# caret::F_meas(Logis_table_new , relevant = "1")

```
